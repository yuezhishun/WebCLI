#  **WS 侧连接状态机**（含背压触发 resync 的阈值建议）

## B) WS 侧连接状态机（前端 ↔ Master）

目标：保证你们的关键体验——**重连一致性、低延迟、背压可控**。

### B.1 状态定义

我建议前端和服务端各自维护一个清晰状态机（实现时用枚举 + 单一 reducer/handler）。

#### 客户端状态

1. `DISCONNECTED`
2. `CONNECTING`
3. `AWAIT_SNAPSHOT`
4. `LIVE`
5. `RESYNCING`
6. `CLOSING`

#### 服务端（每连接）状态

1. `OPENING`（握手完成但未绑定 instance/未鉴权）
2. `BOUND`（鉴权通过 + instance 绑定）
3. `SENDING_SNAPSHOT`
4. `STREAMING_PATCH`
5. `CLOSING`

------

### B.2 关键流程（时序）

#### (1) 初次连接 / 重连

- Client：`CONNECTING` → WS open → `AWAIT_SNAPSHOT`
- Server：鉴权成功 + instance 绑定 → 立即发 `term.snapshot`
- Client：收到 `term.snapshot`（校验 v/type/instance_id/seq）→ 清屏绘制 → `LIVE`

> 这一步是你们一致性的基石：前端不缓存状态，必须靠 snapshot 对齐。

#### (2) LIVE 中处理 patch

- Client：只接受 `seq` 严格递增（`seq <= lastSeq` 丢弃）
- patch 应用失败（数据缺失/解码失败）→ 立即进入 `RESYNCING` 并发 `term.resync`

#### (3) 历史拉取

- Client 在滚动触顶后发 `term.history.get(req_id,before,limit)`
- Server 回 `term.history.chunk(req_id, lines, next_before, exhausted)`
- Client 依据 `req_id` 匹配响应，插入顶部

#### (4) resize

- Client 发 `term.resize(req_id, size)`
- Server resize PTY + 清空历史（按你们简化策略）
- Server 建议直接回一个 `term.snapshot`（最稳）
- Client 收到 snapshot 覆盖当前状态

------

### B.3 心跳与断线检测（强烈建议）

你们 Master–Slave 已有 ping/pong；前端↔Master 同样建议有心跳，否则代理/移动网络容易“半开连接”。

- Server 每 **15s** 发一个 `{"v":1,"type":"ping"}`（或 WS ping 帧）
- Client 收到立即回 `{"v":1,"type":"pong"}`（或 WS pong）
- Server 若 **45s** 未收到 pong：关闭连接（触发客户端重连）

> 如果你用的是 ws 原生 ping/pong 帧更省带宽；但 JSON ping/pong 便于在浏览器侧统一实现。

------

### B.4 背压策略与“触发 resync”的阈值建议

你们目标是低延迟且可承受 burst。关键是：**宁可丢中间 patch，也要尽快收敛到最新屏幕**（因为随时可快照纠正）。

#### 服务端（Master）对每个前端连接维护：

- `pendingBytes`：待发送队列字节数（ws.bufferedAmount 或自维护）
- `pendingMessages`：待发送消息数
- `lastSentSeq`

**建议阈值（MVP 可用、偏保守）**

- `pendingMessages > 50` 或 `pendingBytes > 1MB`：进入 `BACKPRESSURE`（不额外发 patch，只保留最新一帧）
- `pendingMessages > 100` 或 `pendingBytes > 4MB`：触发 **强制 resync**：
  - 丢弃队列中所有 patch（仅保留一个 “resync 标记”）
  - 等队列落到安全值后，直接发送 `term.snapshot`（覆盖一切）

> 解释：你的 patch 通常很小（几行替换），但当前端渲染卡顿或网络抖动，队列会快速堆积。强制快照是最可靠的“收敛操作”。

#### 客户端也可触发 resync

如果客户端发现：

- `seq` 跳跃超过某个阈值（例如 `seq - lastSeq > 500`），或
- 50ms 内收到 patch 太密集导致 UI 丢帧/掉帧（渲染跟不上）
  则主动发送：

```json
{"v":1,"type":"term.resync","instance_id":"...","req_id":"...","reason":"client_backpressure","last_seq":12345}
```

------

### B.5 输出节流（tick 合并）建议

为满足 `<100ms` 体验，建议 Slave（或 Master 聚合层）按 tick 合并输出：

- tick = **16ms（60fps）** 或 **33ms（30fps）**
- tick 内收集“被改动的行集合”，每行只保留最后结果
- tick 结束发送一个 `term.patch`（包含多个 y 行）
- 如果 tick 内改动行很多（> 80% 屏幕），直接发送 snapshot 更划算
