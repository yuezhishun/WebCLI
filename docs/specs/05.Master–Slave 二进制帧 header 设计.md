# (2) Master–Slave 二进制帧 header 设计

## 2) Master–Slave 二进制帧（WS binary message）header 设计

你们的最终目标通信定义是：

- **Master–Slave：WS（二进制帧）**
- **控制指令：Master → Slave JSON**（create/terminate/resize/fetchHistory）
- **数据转发：stdin/stdout 二进制帧透传**
- **心跳：Slave ping，Master pong**。

因此建议协议分两条“子通道”：

- **JSON 文本帧（控制面）**：用普通 WS text message（调试友好）
- **二进制帧（数据面）**：stdin/stdout 透传，用固定 header + payload

下面给一个 **固定长度 header（40 bytes）** 的设计，便于多实例复用同一条 Slave 连接。

### 2.1 Header 布局（固定 40B，大端序）

| 字段            | 大小 | 说明                         |
| --------------- | ---- | ---------------------------- |
| `magic`         | 2    | 固定 `0x57 0x43`（"WC"）     |
| `ver`           | 1    | 协议版本，`1`                |
| `type`          | 1    | 帧类型（见下表）             |
| `flags`         | 1    | 标志位（压缩/ACK/保留）      |
| `header_len`    | 1    | 固定 `40`（便于未来扩展）    |
| `payload_len`   | 4    | payload 字节长度             |
| `seq`           | 8    | 单调递增序列号（可选但推荐） |
| `instance_uuid` | 16   | UUID raw bytes（16B）        |
| `reserved`      | 6    | 预留（对齐 & 扩展）          |

> 为什么建议 `instance_uuid` 用 16B 二进制：你们实例 ID 是全局唯一标识，放二进制比字符串更省且解析更快；同时支持一条 Slave 连接 multiplex 多实例。

### 2.2 帧类型（type）

| type   | 名称            | 方向           | payload                                        |
| ------ | --------------- | -------------- | ---------------------------------------------- |
| `0x01` | `STDIN`         | Master → Slave | 原始输入 bytes（UTF-8 或任意）                 |
| `0x02` | `STDOUT`        | Slave → Master | 原始 PTY 输出 bytes（可选，见备注）            |
| `0x03` | `TERM_PATCH`    | Slave → Master | **建议不用**二进制，改用 text JSON（更易演进） |
| `0x04` | `TERM_SNAPSHOT` | Slave → Master | 同上（建议 JSON，必要时可压缩后走二进制）      |

**重要备注（建议你们这样落地）**

- 虽然文档写“stdin/stdout 二进制透传”，但你们又要求“服务端解析 stdout 生成网格增量/快照以保证重连一致性”。
  所以更推荐：
  - **Master→Slave：STDIN 二进制**（直写 PTY）
  - **Slave→Master：发送解析后的 term.patch/term.snapshot（JSON）**，而不是把 raw stdout 透传到前端
    这样前端的“快照一致性”链路更直，不会出现“前端看到了 stdout 但服务端状态没跟上”的竞态。

### 2.3 一个二进制帧示例（STDIN）

- type=`0x01`
- instance_uuid=某个实例
- payload=`"ls\n"` 的 UTF-8 bytes（`6c 73 0a`）

WS 的一个 binary message = `header(40B) + payload(3B)`

### 2.4 seq / ACK / 丢帧策略（让背压更可控）

你们要达到 `<100ms`，在输出 burst 下“宁可丢中间帧，也要快速收敛到最新屏幕”。

建议规则：

- `seq`：Slave 对每个实例的状态更新单独递增（patch/snapshot）
- Master（或前端）只要发现 seq 跳跃太大/队列积压：
  - 丢弃旧 patch，仅保留最新
  - 或触发 resync：请求/等待一个 snapshot

（对 STDIN 通常不需要 ACK；TCP/WS 已保证有序送达，除非你们要做“输入回显确认”。）

------

如果你希望我继续把这两部分“变成可直接写代码”的程度，我可以下一步补两份更落地的东西（不需要你再补信息也能做）：

1. `term.snapshot/patch/history` 的**严格 JSON Schema**（字段类型、必选/可选、版本演进策略）
2. `ws` 侧的**连接状态机**（connect→snapshot→patch→history/resize→resync→exit），以及“背压触发 resync”的具体阈值建议（按你们 200+ 并发目标来定）。

