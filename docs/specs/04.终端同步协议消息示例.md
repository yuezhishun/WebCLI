#  **(1) 终端同步协议消息示例**

------

## 1) 终端同步协议（前端 ↔ Master，WSS）消息示例

### 1.1 连接握手与“必发快照”

你们要求：**前端不缓存任何终端状态，每次连接/重连都要全量拉取当前屏幕**。
前端连接 URL 参考文档：`wss://master/ws?instance_id=xxx&token=<JWT>`。

建议把“连接后第一帧”定义成服务端主动下发 `term.snapshot`：

#### S → C：`term.snapshot`（连接后立即发送；重连也发送）

```json
{
  "v": 1,
  "type": "term.snapshot",
  "instance_id": "9f5b...uuid",
  "seq": 12034,
  "ts": 1739577600000,
  "size": { "cols": 80, "rows": 25 },
  "cursor": { "x": 12, "y": 7, "visible": true },
  "modes": { "appCursor": false, "wraparound": true },

  "styles": {
    "0": { "fg": null, "bg": null, "bold": false, "italic": false, "underline": false, "inverse": false },
    "1": { "fg": 34, "bg": null, "bold": true,  "italic": false, "underline": false, "inverse": false },
    "2": { "fg": 196, "bg": 16, "bold": false, "italic": false, "underline": false, "inverse": false }
  },

  "rows": [
    { "y": 0, "segs": [ ["login: ",0], ["root",1] ] },
    { "y": 1, "segs": [ ["Last login: ...",0] ] },
    { "y": 2, "segs": [ ["$",0], [" ",0] ] }
    // ... 共 rows 行
  ],

  "history": {
    "available": 1000,
    "newest_cursor": "h:987654321"
  }
}
```

**编码说明（建议）**

- `rows[y].segs` 是“行段（segments）”编码：`[ [text, styleId], ... ]`，同样式连续字符合并，既省内存也省带宽（更容易逼近每实例 <2MB 的目标）。
- `seq`：服务器单调递增序列（用于前端丢弃乱序/重复；也用于“背压下只保留最新 patch”）。
- `history.newest_cursor`：历史游标（下面历史拉取会用）。

> 你们文档描述内部可用 `[][]Cell`，但**网络协议**用 segs 更合适：前端渲染也更轻。

------

### 1.2 实时输入（C → S）与输出更新（S → C）

文档要求：**实时转发输入到 PTY，PTY 输出解析为网格增量更新同步给前端**。

#### C → S：`term.stdin`（建议二进制或 JSON 都行）

如果你们前端输入本质是 UTF-8 文本，MVP 可以先用 JSON（调试方便）：

```json
{ "v": 1, "type": "term.stdin", "instance_id": "9f5b...uuid", "data": "ls -la\n" }
```

> 后续要极致性能/更贴近终端字节流，可以把 `data` 改成**二进制 WS message**（payload 直接是 bytes），但那会让“多实例复用同一连接”的路由更复杂；大多数情况下一个页面只连一个 instance，所以 JSON 足够。

#### S → C：`term.patch`（增量更新）

你们允许“全行替换或差异补丁”，建议 MVP 先用 **全行替换**（实现最稳）。

```json
{
  "v": 1,
  "type": "term.patch",
  "instance_id": "9f5b...uuid",
  "seq": 12035,
  "cursor": { "x": 2, "y": 24, "visible": true },
  "rows": [
    { "y": 24, "segs": [ ["$ ",0], ["ls -la",0] ] }
  ]
}
```

**强烈建议加一条“背压友好”规则**

- 服务端按 16ms/33ms tick 合并 PTY 输出导致的多次行变更：同一 tick 内同一行只保留最后一次结果。
- 如果某个前端连接 send queue 爆了：丢弃中间 patch，保留最新 patch；必要时直接触发一次 `term.snapshot` resync（因为你们的核心一致性来源就是快照）。

------

### 1.3 历史按需拉取（C → S → C）

你们要求：**历史缓冲由服务端维护（默认 1000 行），前端向上滚动超出可视区时按需请求缺失行，50 行需 20ms 内返回**。

#### C → S：`term.history.get`

```json
{
  "v": 1,
  "type": "term.history.get",
  "instance_id": "9f5b...uuid",

  "before": "h:987654321",
  "limit": 50
}
```

- `before`：表示“从哪个历史游标往更老的方向取”（游标由服务端发给前端）。
- `limit`：建议上限 200（避免一次拉太多影响 20ms 目标）。

#### S → C：`term.history.chunk`

```json
{
  "v": 1,
  "type": "term.history.chunk",
  "instance_id": "9f5b...uuid",

  "range": { "from": "h:987654271", "to": "h:987654320" },
  "lines": [
    { "segs": [ ["Line 151",0] ] },
    { "segs": [ ["Line 152",0] ] }
  ],

  "next_before": "h:987654271",
  "exhausted": false
}
```

**前端插入策略（简单且稳定）**

- 历史 chunk 返回的是“更老的 50 行”，前端把它插入当前滚动视图顶部；
- `next_before` 作为下一次继续向上取的 `before`。

------

### 1.4 resize（C → S），以及“清空历史”约束

文档允许 resize 时清空历史缓冲区简化实现。

#### C → S：`term.resize`

```json
{
  "v": 1,
  "type": "term.resize",
  "instance_id": "9f5b...uuid",
  "size": { "cols": 120, "rows": 40 }
}
```

#### S → C：`term.snapshot`（resize 后建议直接再发一次快照）

- 服务端调用 `pty.resize(cols, rows)`
- 终端模拟器调整网格，**清空历史 ring buffer**
- 直接下发一次新的 `term.snapshot`（最省心）

------

### 1.5 进程结束

文档要求结束后前端显示 `[Process completed]`。

#### S → C：`term.exit`

```json
{
  "v": 1,
  "type": "term.exit",
  "instance_id": "9f5b...uuid",
  "code": 0,
  "signal": null,
  "message": "[Process completed]"
}
```
